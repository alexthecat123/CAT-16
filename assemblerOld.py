import sys
import argparse
from shutil import copyfile
import os
import re
import serial
import time
from consolemenu import *
from consolemenu.items import *

parser = argparse.ArgumentParser(description='An Assembler for the CAT-16 Computer')
parser.add_argument('inFile', metavar='inFile', type=str,
                   help='The assembly language file to assemble')
parser.add_argument('outFile', metavar='outFile', type=str,
                   help='The machine code output generated by the assembler')
parser.add_argument('outFormat', metavar='outFormat', type=str, choices=['bin', 'manualEntryBin', 'manualEntryHex', 'autoEntry'],
                   help='The format of the generated machine code (binary, formatted for manual entry at the control panel in binary, manual entry in hex, or automatic entry by the Arduino).')

args = parser.parse_args()


binChars = set('01')
decChars = set('0123456789')
hexChars = set('0123456789ABCDEFabcdef')
modifiers = set('#$%')
allInsts = ['jmp', 'lda', 'adda', 'sta', 'hlt', 'suba', 'nop', 'jca', 'jza', 'outainst', 'outadata', 'outiinst', 'outidata', 'data']
#in = args.inFile
#input = open(args.inFile, 'r')
inFile = open('workingData.txt', 'r+')
#inFile.seek(0)
os.system('cp ' + args.inFile + ' workingData.txt')
'''input = open(args.inFile, 'r')
lines = input.readlines()
inFile = open('workingData.cat','w+')
for line in lines:
    inFile.write(line)
input.close()'''
if args.outFormat == "bin":
    outFile = open(args.outFile, "wb")
else:
    outFile = open(args.outFile, "w")
instructions = inFile.readlines()
#print(instructions)
instructionNum = 1
addressNum = 0

def assembleArgument(argument, relative, immediate):
    global addressNum
    #print(hex(int(immediate, base = 2)))
    if args.outFormat == "manualEntryBin" or args.outFormat == "autoEntry":
        outFile.write(format(addressNum, '016b') + ":        ")
    if args.outFormat == "manualEntryHex":
        outFile.write(format(hex(addressNum)[2:], '0>4') + ":        ")
    addressNum += 2
    if argument.find('#') == 0:
        if immediate == "1111111111111111":
            print("Line " + str(instructionNum) + ": " + "The immediate address mode is not supported for this instruction.")
            sys.exit()
        #print("immediate")
        if args.outFormat == "bin":
            outFile.write(bytes([int(immediate, base = 2)]))
        elif args.outFormat == "manualEntryHex":
            outFile.write(format(hex(int(immediate, base = 2))[2:], '0>4') + " ")
        else:
            outFile.write(immediate + " ")
        if argument.find('$') == 1:
            if not set(argument[2:]).issubset(hexChars):
                print("Line " + str(instructionNum) + ": " + "Hex number specified in argument, but number is not hexadecimal.")
                sys.exit()
            #print("hex")
            if int(argument[2:], base = 16) > 65535:
                print("Line " + str(instructionNum) + ": " + "Argument is greater than 65535.")
                sys.exit()
            if args.outFormat == "bin":
                outFile.write(bytes([int(argument[2:], base = 16)]))
            elif args.outFormat == "manualEntryHex":
                outFile.write(format(hex(int(argument[2:], base = 16))[2:], '0>4') + "\n")
            else:
                outFile.write(format(int(argument[2:], base = 16), '016b') + '\n')
        elif argument.find('%') == 1:
            if not set(argument[2:]).issubset(binChars):
                print("Line " + str(instructionNum) + ": " + "Binary number specified in argument, but number is not binary.")
                sys.exit()
            #print("binary")
            if int(argument[2:], base = 2) > 65535:
                print("Line " + str(instructionNum) + ": " + "Argument is greater than 65535.")
                sys.exit()
            if args.outFormat == "bin":
                outFile.write(bytes([int(argument[2:], base = 2)]))
            elif args.outFormat == "manualEntryHex":
                outFile.write(format(hex(int(argument[2:], base = 2))[2:], '0>4') + "\n")
            else:
                outFile.write(format(int(argument[2:], base = 2), '016b') + '\n')
        elif argument.find('$') != 1 and argument.find('$') != -1:
            print("Line " + str(instructionNum) + ": " + "Extraneous character in argument.")
            sys.exit()
        elif argument.find('%') != 1 and argument.find('%') != -1:
            print("Line " + str(instructionNum) + ": " + "Extraneous character in argument.")
            sys.exit()
        else:
            if not set(argument[1:]).issubset(decChars):
                print("Line " + str(instructionNum) + ": " + "Decimal number specified in argument, but number is not decimal.")
                sys.exit()
            #print("decimal")
            if int(argument[1:], base = 10) > 65535:
                print("Line " + str(instructionNum) + ": " + "Argument is greater than 65535.")
                sys.exit()
            if args.outFormat == "bin":
                outFile.write(bytes([int(argument[1:], base = 10)]))
                #print(bytes([int(argument[1:], base = 10)]))
            elif args.outFormat == "manualEntryHex":
                #print(hex(int(argument[1:], base = 10))[2:])
                outFile.write(format(hex(int(argument[1:], base = 10))[2:], '0>4') + "\n")
            else:
                outFile.write(format(int(argument[1:]), '016b') + '\n')

    elif argument.find('#') > 0:
        print("Line " + str(instructionNum) + ": " + "Extraneous character in argument.")
        sys.exit()
    else:
        if relative == "1111111111111111":
            print("Line " + str(instructionNum) + ": " + "The relative address mode is not supported for this instruction.")
            sys.exit()
        #print("relative")
        if args.outFormat == "bin":
            outFile.write(bytes([int(relative, base = 2)]))
        elif args.outFormat == "manualEntryHex":
            outFile.write(format(hex(int(relative, base = 2))[2:], '0>4') + " ")
        else:
            outFile.write(relative + " ")
        if argument.find('$') == 0:
            if not set(argument[1:]).issubset(hexChars):
                print("Line " + str(instructionNum) + ": " + "Hex number specified in argument, but number is not hexadecimal.")
                sys.exit()
            #print("hex")
            if int(argument[1:], base = 16) > 65535:
                print("Line " + str(instructionNum) + ": " + "Argument is greater than 65535.")
                sys.exit()
            if args.outFormat == "bin":
                outFile.write(bytes([int(argument[1:], base = 16)]))
            elif args.outFormat == "manualEntryHex":
                outFile.write(format(hex(int(argument[1:], base = 16))[2:], '0>4') + "\n")
            else:
                outFile.write(format(int(argument[1:], base = 16), '016b') + '\n')
        elif argument.find('%') == 0:
            if not set(argument[1:]).issubset(binChars):
                print("Line " + str(instructionNum) + ": " + "Binary number specified in argument, but number is not binary.")
                sys.exit()
            #print("binary")
            if int(argument[1:], base = 2) > 65535:
                print("Line " + str(instructionNum) + ": " + "Argument is greater than 65535.")
                sys.exit()
            if args.outFormat == "bin":
                outFile.write(bytes([int(argument[1:], base = 2)]))
            elif args.outFormat == "manualEntryHex":
                outFile.write(format(hex(int(argument[1:], base = 2))[2:], '0>4') + "\n")
            else:
                outFile.write(format(int(argument[1:], base = 2), '016b') + '\n')
        elif argument.find('$') != 0 and argument.find('$') != -1:
            print("Line " + str(instructionNum) + ": " + "Extraneous character in argument.")
            sys.exit()
        elif argument.find('%') != 0 and argument.find('%') != -1:
            print("Line " + str(instructionNum) + ": " + "Extraneous character in argument.")
            sys.exit()
        else:
            if not set(argument).issubset(decChars):
                print("Line " + str(instructionNum) + ": " + "Decimal number specified in argument, but number is not decimal.")
                sys.exit()
            #print("decimal")
            if int(argument[0:], base = 10) > 65535:
                print("Line " + str(instructionNum) + ": " + "Argument is greater than 65535.")
                sys.exit()
            if args.outFormat == "bin":
                outFile.write(bytes([int(argument, base = 10)]))
            elif args.outFormat == "manualEntryHex":
                outFile.write(format(hex(int(argument, base = 10))[2:], '0>4') + "\n")
            else:
                outFile.write(format(int(argument), '016b') + '\n')

for h in range(0, len(instructions)):
    if h < len(instructions):
        instParts = instructions[h].split()
        if len(instParts) == 0:
            instructionNum += 1
            instructionNum -= 1

        elif(instParts[0].casefold() == "hlt"):
            if(len(instParts) > 1):
                if instParts[1][0:1] != ";":
                    print("Line " + str(instructionNum) + ": " + "Too many arguments for HLT (zero needed).")
                    sys.exit()
            if args.outFormat == "manualEntryBin" or args.outFormat == "autoEntry":
                outFile.write(format(addressNum, '016b') + ":        ")
                outFile.write("0000000001011100 ")
            #outFile.write(format(int(instParts[1]), '016b'))
                outFile.write(format(0, '016b') + '\n')
            elif args.outFormat == "manualEntryHex":
                outFile.write(format(hex(addressNum)[2:], '0>4') + ":        ")
                outFile.write(format(hex(int("0000000001011100", base = 2))[2:], '0>4') + " ")
                outFile.write(format(hex(int("0", base = 2))[2:], '0>4') + "\n")
            else:
                outFile.write(bytes([int("0000000001011100", base = 2)]))
                outFile.write(bytes([int("0000000000000000", base = 2)]))

            addressNum += 2


        elif(instParts[0].casefold() == "nop"):
            if(len(instParts) > 1):
                if instParts[1][0:1] != ";":
                    print("Line " + str(instructionNum) + ": " + "Too many arguments for NOP (zero needed).")
                    sys.exit()
            if args.outFormat == "manualEntryBin" or args.outFormat == "autoEntry":
                outFile.write(format(addressNum, '016b') + ":        ")
                outFile.write("0000000001011000 ")
                outFile.write(format(0, '016b') + '\n')
            elif args.outFormat == "manualEntryHex":
                outFile.write(format(hex(addressNum)[2:], '0>4') + ":        ")
                outFile.write(format(hex(int("0000000001011000", base = 2))[2:], '0>4') + " ")
                outFile.write(format(hex(int("0", base = 2))[2:], '0>4') + "\n")
            else:
                outFile.write(bytes([int("0000000001011000", base = 2)]))
                outFile.write(bytes([int("0000000000000000", base = 2)]))
            addressNum += 2

        elif(instParts[0].casefold() == "lda"):
            if(len(instParts) > 2):
                if instParts[2][0:1] != ";":
                    print("Line " + str(instructionNum) + ": " + "Too many arguments for LDA (one needed).")
                    sys.exit()
            elif(len(instParts) < 2):
                print("Line " + str(instructionNum) + ": " + "Not enough arguments for LDA (one needed).")
                sys.exit()
            assembleArgument(instParts[1], "0000000000000000", "0000000000000111")


        elif(instParts[0].casefold() == "sta"):
            if(len(instParts) > 2):
                if instParts[2][0:1] != ";":
                    print("Line " + str(instructionNum) + ": " + "Too many arguments for STA (one needed).")
                    sys.exit()
            elif(len(instParts) < 2):
                print("Line " + str(instructionNum) + ": " + "Not enough arguments for STA (one needed).")
                sys.exit()
            assembleArgument(instParts[1], "0000000000000100", "1111111111111111")


        elif(instParts[0].casefold() == "jmp"):
            if(len(instParts) > 2):
                if instParts[2][0:1] != ";":
                    print("Line " + str(instructionNum) + ": " + "Too many arguments for JMP (one needed).")
                    sys.exit()
            elif(len(instParts) < 2):
                print("Line " + str(instructionNum) + ": " + "Not enough arguments for JMP (one needed).")
                sys.exit()
            if not set(instParts[1][0:1]).issubset(modifiers) and not set(instParts[1]).issubset(decChars):
                #Operand is a label (or invalid)
                #print("found label reference " + instParts[1] + " at address " + str(addressNum))
                newdata = []
                address = 0
                for k in range(0, len(instructions)):
                    #print(instructions[k])
                    if(instructions[k].casefold().find(instParts[1].casefold() + ":") >= 0 and (instructions[k].find(";") == -1 or instructions[k].find(";") >= 3)):
                        if instructions[k].casefold().find(instParts[1].casefold()) in allInsts:
                            print("Line " + str(k) + ": " + "Invalid label name.")
                            sys.exit()
                        #print("here")
                        #meow = instructions[instructionNum - 1].replace(instParts[1], str(address))
                        #print(instParts[1])
                        meow = re.sub(instParts[1], str(address), instructions[instructionNum - 1], flags=re.IGNORECASE)
                        #print(meow)
                        #print(meow)
                        newdata[instructionNum - 1] = meow
                    if instructions[k].casefold().find(instParts[1].casefold() + ":") >= 0:
                        #print("here")
                        newdata.append(instructions[k])
                    else:
                        newdata.append(instructions[k])
                    #print(instParts[0].casefold())
                    #print(newdata)
                    split = instructions[k].split()
                    #print(split)
                    if len(split) > 0:
                        if split[0].casefold() in allInsts:
                            address += 2
                #print(newdata)
                inFile.truncate(0)
                #inFile.seek(0)
                #print(newlines[5])
                inFile.seek(0)
                for l in range(0, len(newdata)):
                    inFile.write(newdata[l])
                inFile.seek(0)
                instructions = inFile.readlines()
                instParts = instructions[h].split()
                #print(instParts[1])
            assembleArgument(instParts[1], "0000000000101001", "1111111111111111")

        elif(instParts[0].casefold() == "adda"):
            if(len(instParts) > 2):
                if instParts[2][0:1] != ";":
                    print("Line " + str(instructionNum) + ": " + "Too many arguments for ADDA (one needed).")
                    sys.exit()
            elif(len(instParts) < 2):
                print("Line " + str(instructionNum) + ": " + "Not enough arguments for ADDA (one needed).")
                sys.exit()
            assembleArgument(instParts[1], "0000000000001011", "0000000000001111")



        elif(instParts[0].casefold() == "suba"):
            if(len(instParts) > 2):
                if instParts[2][0:1] != ";":
                    print("Line " + str(instructionNum) + ": " + "Too many arguments for SUBA (one needed).")
                    sys.exit()
            elif(len(instParts) < 2):
                print("Line " + str(instructionNum) + ": " + "Not enough arguments for SUBA (one needed).")
                sys.exit()
            assembleArgument(instParts[1], "0000000000001100", "0000000000010000")

        elif(instParts[0].casefold() == "jca"):
            if(len(instParts) > 2):
                if instParts[2][0:1] != ";":
                    print("Line " + str(instructionNum) + ": " + "Too many arguments for JCA (one needed).")
                    sys.exit()
            elif(len(instParts) < 2):
                print("Line " + str(instructionNum) + ": " + "Not enough arguments for JCA (one needed).")
                sys.exit()
            if not set(instParts[1][0:1]).issubset(modifiers) and not set(instParts[1]).issubset(decChars):
                #Operand is a label (or invalid)
                #print("found label reference " + instParts[1] + " at address " + str(addressNum))
                newdata = []
                address = 0
                for k in range(0, len(instructions)):
                    #print(instructions[k])
                    if(instructions[k].casefold().find(instParts[1].casefold() + ":") >= 0 and (instructions[k].find(";") == -1 or instructions[k].find(";") >= 3)):
                        if instructions[k].casefold().find(instParts[1].casefold()) in allInsts:
                            print("Line " + str(k) + ": " + "Invalid label name.")
                            sys.exit()
                        #print("here")
                        #meow = instructions[instructionNum - 1].replace(instParts[1], str(address))
                        #print(instParts[1])
                        meow = re.sub(instParts[1], str(address), instructions[instructionNum - 1], flags=re.IGNORECASE)
                        #print(meow)
                        #print(meow)
                        newdata[instructionNum - 1] = meow
                    if instructions[k].casefold().find(instParts[1].casefold() + ":") >= 0:
                        #print("here")
                        newdata.append(instructions[k])
                    else:
                        newdata.append(instructions[k])
                    #print(instParts[0].casefold())
                    #print(newdata)
                    split = instructions[k].split()
                    #print(split)
                    if len(split) > 0:
                        if split[0].casefold() in allInsts:
                            address += 2
                #print(newdata)
                inFile.truncate(0)
                #inFile.seek(0)
                #print(newlines[5])
                inFile.seek(0)
                for l in range(0, len(newdata)):
                    inFile.write(newdata[l])
                inFile.seek(0)
                instructions = inFile.readlines()
                instParts = instructions[h].split()
                #print(instParts[1])

            assembleArgument(instParts[1], "0000000000101011", "1111111111111111")


        elif(instParts[0].casefold() == "jza"):
            if(len(instParts) > 2):
                if instParts[2][0:1] != ";":
                    print("Line " + str(instructionNum) + ": " + "Too many arguments for JZA (one needed).")
                    sys.exit()
            elif(len(instParts) < 2):
                print("Line " + str(instructionNum) + ": " + "Not enough arguments for JZA (one needed).")
                sys.exit()
            if not set(instParts[1][0:1]).issubset(modifiers) and not set(instParts[1]).issubset(decChars):
                #Operand is a label (or invalid)
                #print("found label reference " + instParts[1] + " at address " + str(addressNum))
                newdata = []
                address = 0
                for k in range(0, len(instructions)):
                    #print(instructions[k])
                    if(instructions[k].casefold().find(instParts[1].casefold() + ":") >= 0 and (instructions[k].find(";") == -1 or instructions[k].find(";") >= 3)):
                        if instructions[k].casefold().find(instParts[1].casefold()) in allInsts:
                            print("Line " + str(k) + ": " + "Invalid label name.")
                            sys.exit()
                        #print("here")
                        #meow = instructions[instructionNum - 1].replace(instParts[1], str(address))
                        #print(instParts[1])
                        meow = re.sub(instParts[1], str(address), instructions[instructionNum - 1], flags=re.IGNORECASE)
                        #print(meow)
                        #print(meow)
                        newdata[instructionNum - 1] = meow
                    if instructions[k].casefold().find(instParts[1].casefold() + ":") >= 0:
                        #print("here")
                        newdata.append(instructions[k])
                    else:
                        newdata.append(instructions[k])
                    #print(instParts[0].casefold())
                    #print(newdata)
                    split = instructions[k].split()
                    #print(split)
                    if len(split) > 0:
                        if split[0].casefold() in allInsts:
                            address += 2
                #print(newdata)
                inFile.truncate(0)
                #inFile.seek(0)
                #print(newlines[5])
                inFile.seek(0)
                for l in range(0, len(newdata)):
                    inFile.write(newdata[l])
                inFile.seek(0)
                instructions = inFile.readlines()
                instParts = instructions[h].split()
                #print(instParts[1])
            assembleArgument(instParts[1], "0000000000110001", "1111111111111111")

        elif(instParts[0].casefold() == "outainst"):
            if(len(instParts) > 1):
                if instParts[1][0:1] != ";":
                    print("Line " + str(instructionNum) + ": " + "Too many arguments for OUTAINST (zero needed).")
                    sys.exit()
            if args.outFormat == "manualEntryBin" or args.outFormat == "autoEntry":
                outFile.write(format(addressNum, '016b') + ":        ")
                outFile.write("0000000001011001 ")
                outFile.write(format(0, '016b') + '\n')
            elif args.outFormat == "manualEntryHex":
                outFile.write(format(hex(addressNum)[2:], '0>4') + ":        ")
                outFile.write(format(hex(int("0000000001011001", base = 2))[2:], '0>4') + " ")
                outFile.write(format(hex(int("0", base = 2))[2:], '0>4') + "\n")
            else:
                outFile.write(bytes([int("0000000001011001", base = 2)]))
                outFile.write(bytes([int("0000000000000000", base = 2)]))
            addressNum += 2


        elif(instParts[0].casefold() == "outadata"):
            if(len(instParts) > 1):
                if instParts[1][0:1] != ";":
                    print("Line " + str(instructionNum) + ": " + "Too many arguments for OUTADATA (zero needed).")
                    sys.exit()
            if args.outFormat == "manualEntryBin" or args.outFormat == "autoEntry":
                outFile.write(format(addressNum, '016b') + ":        ")
                outFile.write("0000000001011101 ")
                outFile.write(format(0, '016b') + '\n')
            elif args.outFormat == "manualEntryHex":
                outFile.write(format(hex(addressNum)[2:], '0>4') + ":        ")
                outFile.write(format(hex(int("0000000001011101", base = 2))[2:], '0>4') + " ")
                outFile.write(format(hex(int("0", base = 2))[2:], '0>4') + "\n")
            else:
                outFile.write(bytes([int("0000000001011101", base = 2)]))
                outFile.write(bytes([int("0000000000000000", base = 2)]))
            addressNum += 2

        elif(instParts[0].casefold() == "outiinst"):
            if(len(instParts) > 2):
                if instParts[2][0:1] != ";":
                    print("Line " + str(instructionNum) + ": " + "Too many arguments for OUTIINST (one needed).")
                    sys.exit()
            elif(len(instParts) < 2):
                print("Line " + str(instructionNum) + ": " + "Not enough arguments for OUTIINST (one needed).")
                sys.exit()
            assembleArgument(instParts[1], "1111111111111111", "0000000001011110")

        elif(instParts[0].casefold() == "outidata"):
            if(len(instParts) > 2):
                if instParts[2][0:1] != ";":
                    print("Line " + str(instructionNum) + ": " + "Too many arguments for OUTIDATA (one needed).")
                    sys.exit()
            elif(len(instParts) < 2):
                print("Line " + str(instructionNum) + ": " + "Not enough arguments for OUTIDATA (one needed).")
                sys.exit()
            assembleArgument(instParts[1], "1111111111111111", "0000000001011111")

        elif(instParts[0].casefold() == "data"):
            if(len(instParts) < 2):
                print("Line " + str(instructionNum) + ": " + "Not enough arguments for DATA (one needed).")
                sys.exit()
            #print(len(instParts))
            comment = False
            if instParts[1][0] == '"' or instParts[1][0] == "'":
                #print("here")
                stop = False
                for z in range(1, len(instParts)):
                    oddEven = 0
                    temp = instParts[z].replace("'", "")
                    newParts = temp.replace('"', "")
                    if ";" in newParts:
                        break
                    if z < len(instParts) - 1:
                        newParts = newParts + " "
                    for a in range(0, len(newParts), 2):
                        '''if instParts[z][a] == "'" or instParts[z][a] == '""' or instParts[z][a + 1] == "'" or instParts[z][a + 1] == '""':
                            stop = True'''
                        if args.outFormat == "manualEntryBin" or args.outFormat == "autoEntry":
                            outFile.write(format(addressNum, '016b') + ":        ")
                            outFile.write(format(ord(newParts[a]), '016b') + " ")
                            oddEven += 1

                            try:
                                outFile.write(format(ord(newParts[a + 1]), '016b') + '\n')
                                oddEven += 1
                            except:
                                oddEven += 1
                                print(addressNum)
                                outFile.write("0000000000000000" + '\n')
                        elif args.outFormat == "manualEntryHex":
                            outFile.write(format(hex(addressNum)[2:], '0>4') + ":        ")
                            outFile.write(format(hex(ord(newParts[a]))[2:], '0>4') + " ")
                            try:
                                outFile.write(format(hex(ord(newParts[a + 1]))[2:], '0>4') + "\n")
                            except:
                                outFile.write(format(hex(int("0", base = 2))[2:], '0>4') + "\n")
                        else:
                            outFile.write(bytes([ord(newParts[a])]))
                            try:
                                outFile.write(bytes([ord(newParts[a + 1])]))
                            except:
                                outFile.write(bytes([int("0000000000000000", base = 10)]))
                        addressNum += 2
                #if oddEven % 2 != 0:
                #    outFile.write("0000000000000000" + '\n')
            else:
                for x in range(1, len(instParts), 2):
                    if instParts[x][0] == ";":
                        comment = True
                    #print("here")
                    instParts[x] =instParts[x].replace(",", "")
                    try:
                        instParts[x + 1] = instParts[x + 1].replace(",", "")
                    except:
                        instructionNum += 1
                        instructionNum -= 1
                    #print(instParts)
                    if instParts[x].find('$') == 0 and comment == False:
                        if not set(instParts[x][1:]).issubset(hexChars):
                            print("Line " + str(instructionNum) + ": " + "Hex number specified in argument, but number is not hexadecimal.")
                            sys.exit()
                        #print("hex")
                        if int(instParts[x][1:], base = 16) > 65535:
                            print("Line " + str(instructionNum) + ": " + "Argument is greater than 65535.")
                            sys.exit()
                        try:
                            if instParts[x + 1][0] != "$" and instParts[x + 1][0] != ";":
                                print("Line " + str(instructionNum) + ": " + "Data argument " + instParts[x] + " is a different type from argument " + instParts[x + 1])
                                sys.exit()
                        except SystemExit:
                            sys.exit()
                        except:
                            instructionNum += 1
                            instructionNum -= 1
                        if args.outFormat == "manualEntryBin" or args.outFormat == "autoEntry":
                            outFile.write(format(addressNum, '016b') + ":        ")
                            outFile.write(format(int(instParts[x][1:], base = 16), '016b') + " ")

                            if instParts[x + 1][0] == ";":
                                comment = True
                            try:
                                outFile.write(format(int(instParts[x + 1][1:], base = 16), '016b') + '\n')
                            except:
                                outFile.write("0000000000000000" + '\n')

                        elif args.outFormat == "manualEntryHex":
                            outFile.write(format(hex(addressNum)[2:], '0>4') + ":        ")
                            outFile.write(format(hex(int(instParts[x][1:], base = 16))[2:], '0>4') + " ")

                            if instParts[x + 1][0] == ";":
                                comment = True

                            try:
                                outFile.write(format(hex(int(instParts[x + 1][1:], base = 16))[2:], '0>4') + "\n")
                            except:
                                outFile.write(format(hex(int("0", base = 2))[2:], '0>4') + "\n")

                        else:
                            outFile.write(bytes([int(instParts[x][1:], base = 16)]))
                            try:
                                outFile.write(bytes([int(instParts[x + 1][1:], base = 16)]))
                            except:
                                outFile.write(bytes([int("0000000000000000", base = 16)]))
                        addressNum += 2
                    elif instParts[x].find('%') == 0 and comment == False:
                        if not set(instParts[x][1:]).issubset(binChars):
                            print("Line " + str(instructionNum) + ": " + "Binary number specified in argument, but number is not binary.")
                            sys.exit()
                        #print("binary")
                        if int(instParts[x][1:], base = 2) > 65535:
                            print("Line " + str(instructionNum) + ": " + "Argument is greater than 65535.")
                            sys.exit()
                        try:
                            if instParts[x + 1][0] != "%" and instParts[x + 1][0] != ";":
                                print("Line " + str(instructionNum) + ": " + "Data argument " + instParts[x] + " is a different type from argument " + instParts[x + 1])
                                sys.exit()
                        except SystemExit:
                            sys.exit()
                        except:
                            instructionNum += 1
                            instructionNum -= 1
                        if args.outFormat == "manualEntryBin" or args.outFormat == "autoEntry":
                            outFile.write(format(addressNum, '016b') + ":        ")
                            outFile.write(format(int(instParts[x][1:], base = 2), '016b') + " ")

                            if instParts[x + 1][0] == ";":
                                comment = True
                            try:
                                outFile.write(format(int(instParts[x + 1][1:], base = 2), '016b') + '\n')
                            except:
                                outFile.write("0000000000000000" + '\n')
                        elif args.outFormat == "manualEntryHex":
                            outFile.write(format(hex(addressNum)[2:], '0>4') + ":        ")
                            outFile.write(format(hex(int(instParts[x][1:], base = 2))[2:], '0>4') + " ")

                            if instParts[x + 1][0] == ";":
                                comment = True

                            try:
                                outFile.write(format(hex(int(instParts[x + 1][1:], base = 2))[2:], '0>4') + "\n")
                            except:
                                outFile.write(format(hex(int("0", base = 2))[2:], '0>4') + "\n")
                        else:
                            outFile.write(bytes([int(instParts[x][1:], base = 2)]))
                            try:
                                outFile.write(bytes([int(instParts[x + 1][1:], base = 2)]))
                            except:
                                outFile.write(bytes([int("0000000000000000", base = 2)]))
                        addressNum += 2
                    elif instParts[x].find('$') != 0 and instParts[x].find('$') != -1:
                        print("Line " + str(instructionNum) + ": " + "Extraneous character in argument.")
                        sys.exit()
                    elif instParts[x].find('%') != 0 and instParts[x].find('%') != -1:
                        print("Line " + str(instructionNum) + ": " + "Extraneous character in argument.")
                        sys.exit()
                    else:
                        if comment == False:
                            if not set(instParts[x]).issubset(decChars):
                                print("Line " + str(instructionNum) + ": " + "Decimal number specified in argument, but number is not decimal.")
                                sys.exit()
                            #print("decimal")
                            if int(instParts[x][0:], base = 10) > 65535:
                                print("Line " + str(instructionNum) + ": " + "Argument is greater than 65535.")
                                sys.exit()
                            try:
                                if instParts[x + 1][0] == "$" or instParts[x + 1][0] == "%" and instParts[x + 1][0] != ";":
                                    print("Line " + str(instructionNum) + ": " + "Data argument " + instParts[x] + " is a different type from argument " + instParts[x + 1])
                                    sys.exit()
                            except SystemExit:
                                sys.exit()
                            except:
                                instructionNum += 1
                                instructionNum -= 1
                            if args.outFormat == "manualEntryBin" or args.outFormat == "autoEntry":
                                outFile.write(format(addressNum, '016b') + ":        ")
                                outFile.write(format(int(instParts[x], base = 10), '016b') + " ")

                                if instParts[x + 1][0] == ";":
                                    comment = True

                                try:
                                    outFile.write(format(int(instParts[x + 1], base = 10), '016b') + '\n')
                                except:
                                    outFile.write("0000000000000000" + '\n')
                            elif args.outFormat == "manualEntryHex":
                                outFile.write(format(hex(addressNum)[2:], '0>4') + ":        ")
                                outFile.write(format(hex(int(instParts[x]))[2:], '0>4') + " ")

                                if instParts[x + 1][0] == ";":
                                    comment = True
                                try:
                                    outFile.write(format(hex(int(instParts[x + 1]))[2:], '0>4') + "\n")
                                except:
                                    outFile.write(format(hex(int("0", base = 2))[2:], '0>4') + "\n")
                            else:
                                outFile.write(bytes([int(instParts[x], base = 10)]))
                                try:
                                    outFile.write(bytes([int(instParts[x + 1], base = 10)]))
                                except:
                                    outFile.write(bytes([int("0000000000000000", base = 10)]))
                            addressNum += 2


        elif instParts[0][0:1] == ";":
            instructionNum -= 1
            instructionNum += 1


        elif len(instParts) == 3 and instParts[1] == "=" and instParts[0] == "*":
            if instParts[2].find('$') == 0:
                if not set(instParts[2][1:]).issubset(hexChars):
                    print("Line " + str(instructionNum) + ": " + "Hex number specified in argument, but number is not hexadecimal.")
                    sys.exit()
                #print("hex")
                if int(instParts[2][1:], base = 16) > 65535:
                    print("Line " + str(instructionNum) + ": " + "Argument is greater than 65535.")
                    sys.exit()
                addressNum = int(instParts[2][1:], base = 16)
            elif instParts[2].find('%') == 0:
                if not set(instParts[2][1:]).issubset(binChars):
                    print("Line " + str(instructionNum) + ": " + "Binary number specified in argument, but number is not binary.")
                    sys.exit()
                #print("binary")
                if int(instParts[2][1:], base = 2) > 65535:
                    print("Line " + str(instructionNum) + ": " + "Argument is greater than 65535.")
                    sys.exit()
                addressNum = int(instParts[2][1:], base = 2)
            elif instParts[2].find('$') != 0 and instParts[2].find('$') != -1:
                print("Line " + str(instructionNum) + ": " + "Extraneous character in argument.")
                sys.exit()
            elif instParts[2].find('%') != 0 and instParts[2].find('%') != -1:
                print("Line " + str(instructionNum) + ": " + "Extraneous character in argument.")
                sys.exit()
            else:
                if not set(instParts[2]).issubset(decChars):
                    print("Line " + str(instructionNum) + ": " + "Decimal number specified in argument, but number is not decimal.")
                    sys.exit()
                #print("decimal")
                if int(instParts[2][0:], base = 10) > 65535:
                    print("Line " + str(instructionNum) + ": " + "Argument is greater than 65535.")
                    sys.exit()
                addressNum = int(instParts[2], base = 10)

        elif len(instParts) >= 3 and instParts[1] == "=" and instParts[0] != "*" and not set(instParts[0]).issubset(allInsts):
            #print("here")
            #print(instParts)
            newlines = []
            if any((instParts[0] + ":").upper() in s.upper() for s in instructions):
                print("Line " + str(instructionNum) + ": " + "Both a label and a variable share the name " + instParts[0])
                sys.exit()
            #print(instParts[2])
            '''if instParts[2].find('$') == 0:
                #print("here")
                if not set(instParts[2][1:]).issubset(hexChars):
                    print("Line " + str(instructionNum) + ": " + "Hex number specified in argument, but number is not hexadecimal.")
                    sys.exit()
                #print("hex")
                if int(instParts[2][1:], base = 16) > 65535:
                    print("Line " + str(instructionNum) + ": " + "Argument is greater than 65535.")
                    sys.exit()
                if args.outFormat == "bin":
                    outFile.write(bytes([int(instParts[2][1:], base = 16)]))
                    outFile.write(bytes([int("0000000000000000", base = 16)]))
                else:
                    outFile.write(format(addressNum, '016b') + ":        ")
                    outFile.write(format(int(instParts[2][1:], base = 16), '016b') + ' ')
                    outFile.write("0000000000000000" + '\n')

            elif instParts[2].find('%') == 0:
                if not set(instParts[2][1:]).issubset(binChars):
                    print("Line " + str(instructionNum) + ": " + "Binary number specified in argument, but number is not binary.")
                    sys.exit()
                #print("binary")
                if int(instParts[2][1:], base = 2) > 65535:
                    print("Line " + str(instructionNum) + ": " + "Argument is greater than 65535.")
                    sys.exit()
                if args.outFormat == "bin":
                    outFile.write(bytes([int(instParts[2][1:], base = 2)]))
                    outFile.write(bytes([int("0000000000000000", base = 2)]))
                else:
                    outFile.write(format(addressNum, '016b') + ":        ")
                    outFile.write(format(int(instParts[2][1:], base = 2), '016b') + ' ')
                    outFile.write("0000000000000000" + '\n')
            else:
                if not set(instParts[2]).issubset(decChars):
                    print("Line " + str(instructionNum) + ": " + "Decimal number specified in argument, but number is not decimal.")
                    sys.exit()
                #print("decimal")
                if int(instParts[2], base = 10) > 65535:
                    print("Line " + str(instructionNum) + ": " + "Argument is greater than 65535.")
                    sys.exit()
                if args.outFormat == "bin":
                    outFile.write(bytes([int(instParts[2][1:], base = 10)]))
                    outFile.write(bytes([int("0000000000000000", base = 10)]))
                else:
                    outFile.write(format(addressNum, '016b') + ":        ")
                    outFile.write(format(int(instParts[2], base = 10), '016b') + ' ')
                    outFile.write("0000000000000000" + '\n')'''


            for y in range(0, len(instructions)):
                instructParts = instructions[y].split()
                if(instructions[y].find(":") == -1 and (instructions[y].find(";") >= 3 or instructions[y].find(";") == -1) and len(instructParts) >= 2 and instructParts[0] != "data" and instructions[y].find("=") == -1):
                    line = re.sub(instParts[0], instParts[2], instructParts[1], flags=re.IGNORECASE)
                    newlines.append(instructParts[0] + " " + line + "\n")
                else:
                    newlines.append(instructions[y])
            #print(newlines)
            inFile.truncate(0)
            #inFile.seek(0)
            #print(newlines[5])
            inFile.seek(0)
            for i in range(0, len(newlines)):
                inFile.write(newlines[i])
            inFile.seek(0)
            instructions = inFile.readlines()
            #addressNum += 2
            #print(instructions[5])

        elif instParts[0][-1] == ":":
            if instParts[0][0:len(instParts[0]) - 1].casefold() in allInsts:
                print("Line " + str(instructionNum) + ": " + "Invalid label name.")
                sys.exit()
            #print("found label " + instParts[0][0:len(instParts[0]) - 1] + " at address " + str(addressNum))
            newlines = []
            for j in range(0, len(instructions)):
                parts = instructions[j].split()
                if(instructions[j].find(":") == -1 and (instructions[j].find(";") >= 3 or instructions[j].find(";") == -1) and len(parts) >= 2 and parts[0] != "data" and instructions[j].find("=") == -1):
                    #actualText = instParts[0][0:len(instParts[0]) - 1].lower()
                    #print(actualText)
                    #print(actualText)
                    #print(j)
                    #print(instructions[j][1])
                    #print(parts[1])
                    #print(instParts[0][0:len(instParts[0]) - 1])
                    #print(parts[1])
                    line = re.sub(instParts[0][0:len(instParts[0]) - 1], str(addressNum), parts[1], flags=re.IGNORECASE)
                    #print(line)
                    #instructions[j].replace(parts[1], str(addressNum))
                    newlines.append(parts[0] + " " + line + "\n")
                else:
                    newlines.append(instructions[j])
            #print(newlines)
            inFile.truncate(0)
            #inFile.seek(0)
            #print(newlines[5])
            inFile.seek(0)
            for i in range(0, len(newlines)):
                inFile.write(newlines[i])
            inFile.seek(0)
            instructions = inFile.readlines()
            #print(instructions[5])
        else:
            print("Line " + str(instructionNum) + ": " + "Unknown instruction")
            sys.exit()
        if(addressNum > 65535):
            print("Line " + str(instructionNum) + ": " + "Ran out of memory!")
            sys.exit()
        instructionNum += 1

print("Assembly successful!!!")
arduino = serial.Serial('/dev/cu.usbserial-1420')
time.sleep(2)
if(args.outFormat == "autoEntry"):
    outFile.close()
    print("Entering assembled code into RAM...")
    outFile = open(args.outFile, "r")
    binLines = outFile.readlines()
    for d in range(0, len(binLines)):
        rawData = binLines[d].split()
        arduino.write(bytes(rawData[0], 'utf8'))
        time.sleep(0.05)
        arduino.write(bytes(rawData[1], 'utf8'))
        time.sleep(0.05)
        arduino.write(bytes(rawData[2], 'utf8'))
        time.sleep(0.05)
    print("Done!")

arduino.write(b"10001000101110000")
time.sleep(0.05)

def SSC():
    os.system('clear')
    print("----- CAT-16 Clock Control Panel -----")
    print("1 - Step Clock")
    print("2 - Reset Computer")
    print("3 - Return to Main Menu")
    print()
    choice = input("Please input your choice: ")
    if choice == "1":
        arduino.write(b"10001000101111111")
        time.sleep(0.05)
        SSC()
    elif choice == "2":
        arduino.write(b"10001000101110100")
        time.sleep(0.05)
        SSC()
    elif choice == "3":
        arduino.write(b"10001000101110011")
        time.sleep(0.05)
        mainCP()
    else:
        SSC()

def CS():
    os.system('clear')
    print("----- CAT-16 Clock Control Panel -----")
    choice = input("Please input the desired clock speed in Hertz: ")
    if not set(choice).issubset(decChars):
        CS()
    else:
        arduino.write(bytes(choice, 'utf8'))
        FRC()
def FRC():
    os.system('clear')
    print("----- CAT-16 Clock Control Panel -----")
    print("1 - Start Clock")
    print("2 - Stop Clock")
    print("3 - Change Clock Speed")
    print("4 - Reset Computer")
    print("5 - Return to Main Menu")
    print()
    choice = input("Please input your choice: ")
    if choice == "1":
        arduino.write(b"10001000101110101")
        time.sleep(0.05)
        FRC()
    elif choice == "2":
        arduino.write(b"10001000101110110")
        time.sleep(0.05)
        FRC()
    elif choice == "3":
        CS()
    elif choice == "4":
        arduino.write(b"10001000101110100")
        time.sleep(0.05)
        FRC()
    elif choice == "5":
        arduino.write(b"10001000101110011")
        time.sleep(0.05)
        mainCP()
    else:
        FRC()

def mainCP():
    os.system('clear')
    print("----- CAT-16 Clock Control Panel -----")
    print("1 - Free-Running Clock")
    print("2 - Single Step Clock")
    print("3 - Reset Computer")
    print("4 - Exit")
    print()
    choice = input("Please input your choice: ")
    if choice == "1":
        arduino.write(b"10001000101110001")
        time.sleep(0.05)
        FRC()
    elif choice == "2":
        arduino.write(b"10001000101110010")
        time.sleep(0.05)
        SSC()
    elif choice == "3":
        arduino.write(b"10001000101110100")
        time.sleep(0.05)
        mainCP()
    elif choice == "4":
        os.system('clear')
        sys.exit()
    else:
        mainCP()
mainCP()
'''arduino.write(b"10001000101110010")
time.sleep(0.05)
arduino.write(b"10001000101111111")
time.sleep(0.05)'''
